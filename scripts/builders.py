"""Provides builder classes for MATSim XML files."""
import datetime
from typing import Iterable, Tuple, Union

from lxml import etree
from lxml.builder import E

from .shared import ActivityType, Facility


class ConfigBuilder:
    """Builder class for `config.xml`"""

    def __init__(
        self,
        *,
        network_file: str,
        facilities_file: str,
        plans_file: str,
        output_dir: str,
        random_seed: int,
    ) -> None:
        """Constructs a ConfigBuilder object.

        Args:
            network_file: Path to `network.xml`
            facilities_file: Path to `facilities.xml`
            plans_file: Path to `plans.xml`
            output_dir: Output directory for simulation result
            random_seed: Random seed value for MATSim to use.
                Must be a signed 64-bit integer.
        """
        self._root_elem = E.config(
            etree.Comment("Generated by " + __file__),
            E.module(
                {"name": "global"},
                E.param(name="coordinateSystem", value="Atlantis"),
                E.param(
                    name="randomSeed",
                    value=str(random_seed),
                ),
            ),
            E.module(
                {"name": "network"},
                E.param(name="inputNetworkFile", value=network_file),
            ),
            E.module(
                {"name": "facilities"},
                E.param(name="inputFacilitiesFile", value=facilities_file),
                E.param(name="facilitiesSource", value="fromFile"),
            ),
            E.module(
                {"name": "plans"}, E.param(name="inputPlansFile", value=plans_file)
            ),
            E.module(
                # "controler" is not a typo, MATSim actually uses this
                {"name": "controler"},
                E.param(name="firstIteration", value="0"),
                etree.Comment("Default value is 1000, which is too large for our use"),
                E.param(name="lastIteration", value="20"),
                # Default value: "./output"
                E.param(name="outputDirectory", value=output_dir),
            ),
            E.module(
                {"name": "planCalcScore"},
                # Controls how much previous scores affect the next score in
                # each iteration:
                #   score = (learningRate) * (new_score) + (1 - learningRate) * (prev_score)
                # (default is 1)
                E.param(name="learningRate", value="1.0"),
                E.param(name="BrainExpBeta", value="2.0"),
                E.parameterset(
                    {"type": "scoringParameters"},
                    # Penalty for arriving after the activity begins
                    # (score per hour, multiplied with amount of missed time)
                    E.param(name="lateArrival", value="-18"),
                    # Penalty for leaving before the activity ends
                    # (score per hour, multiplied with amount of missed time)
                    E.param(name="earlyDeparture", value="-0"),
                    # Bonus for performing an activity (e.g. home, work),
                    # measured in score per hour.
                    # The formula is complicated and is not described here;
                    # see section 5.2.1.2 of the MATSim User Guide.
                    E.param(name="performing", value="+6"),
                    # Penalty for arriving before the activity begins
                    # (score per hour, multiplied with time spent waiting).
                    # Note: The User Guide recommends setting this to 0.
                    E.param(name="waiting", value="-0"),
                    # --------------------------------
                    # Scoring parameters for travel modes
                    #
                    # Note: In MATSim, traveling generally reduces the utility
                    # (score) of a plan, so that time and money spent on
                    # traveling is minimized.
                    # --------------------------------
                    E.parameterset(
                        {"type": "modeParams"},
                        # Travel mode for driving a car
                        E.param(name="mode", value="car"),
                        # Penalty for time spent traveling
                        # (score per hour, multiplied with travel duration)
                        # Note: This is calculated separately from the general
                        # opportunity cost of time spent on traveling.
                        # (default value: -6.0)
                        E.param(
                            name="marginalUtilityOfTraveling_util_hr", value="-6.0"
                        ),
                    ),
                    E.parameterset(
                        {"type": "modeParams"},
                        # Travel mode that models public transit (pt).
                        # Note: You can use parameters such as
                        # "teleportedModeFreespeedFactor" to roughly model
                        # public transit.
                        # See section 7.2.1 of MATSim User Guide for more info.
                        E.param(name="mode", value="pt"),
                    ),
                    E.parameterset(
                        {"type": "modeParams"},
                        # Travel mode that models walking
                        E.param(name="mode", value="walk"),
                    ),
                    # --------------------------------
                    # Scoring parameters for activities
                    #
                    # Note: In MATSim, activities generally increase the utility
                    # (score) of a plan, so that each agent tries to fully
                    # participate in all desired activities.
                    # --------------------------------
                    E.parameterset(
                        {"type": "activityParams"},
                        E.param(name="activityType", value="home"),
                        E.param(name="priority", value="1"),
                        E.param(name="typicalDuration", value="12:00:00"),
                        E.param(name="minimalDuration", value="08:00:00"),
                    ),
                    E.parameterset(
                        {"type": "activityParams"},
                        E.param(name="activityType", value="work"),
                        E.param(name="priority", value="1"),
                        E.param(name="typicalDuration", value="08:00:00"),
                        E.param(name="minimalDuration", value="06:00:00"),
                        E.param(name="openingTime", value="07:00:00"),
                        E.param(name="latestStartTime", value="09:00:00"),
                        E.param(name="earliestEndTime", value=""),
                        E.param(name="closingTime", value="20:00:00"),
                    ),
                    E.parameterset(
                        {"type": "activityParams"},
                        E.param(name="activityType", value="shopping"),
                        E.param(name="priority", value="1"),
                        E.param(name="typicalDuration", value="00:30:00"),
                        E.param(name="minimalDuration", value="00:05:00"),
                        E.param(name="openingTime", value="17:00:00"),
                        E.param(name="latestStartTime", value="18:00:00"),
                        E.param(name="earliestEndTime", value=""),
                        E.param(name="closingTime", value="22:00:00"),
                    ),
                ),
            ),
            E.module(
                {"name": "strategy"},
                etree.Comment("0 means unlimited"),
                E.param(name="maxAgentPlanMemorySize", value="5"),
                E.parameterset(
                    {"type": "strategysettings"},
                    E.param(name="strategyName", value="BestScore"),
                    E.param(name="weight", value="0.9"),
                ),
                E.parameterset(
                    {"type": "strategysettings"},
                    E.param(name="strategyName", value="ReRoute"),
                    E.param(name="weight", value="0.1"),
                ),
            ),
        )
        self._tree = etree.ElementTree(element=self._root_elem)

    def write(self, filename: str) -> None:
        """Writes the XML to a file."""
        self._tree.write(
            filename,
            doctype='<!DOCTYPE config SYSTEM "http://www.matsim.org/files/dtd/config_v2.dtd">',
            encoding="utf-8",
            pretty_print=True,
            xml_declaration=True,
        )


class FacilitiesBuilder:
    """Builder class for `facilities.xml`"""

    def __init__(self):
        self._root_elem = etree.Element("facilities")
        self._root_elem.append(etree.Comment("Generated by " + __file__))

        self._tree = etree.ElementTree(element=self._root_elem)

        self._next_facility_id = 1

    def add_facility(
        self, x: float, y: float, activity_types: Iterable[ActivityType]
    ) -> Facility:
        """Add a facility with one or more activities."""
        facility_id = self._next_facility_id
        facility_elem = etree.SubElement(
            self._root_elem,
            "facility",
            {
                "id": str(facility_id),
                "x": str(float(x)),
                "y": str(float(y)),
            },
        )
        self._next_facility_id += 1

        activity_types_set = frozenset(activity_types)
        for activity_type in activity_types_set:
            etree.SubElement(facility_elem, "activity", {"type": activity_type})

        return Facility(id=facility_id, x=x, y=y, activity_types=activity_types_set)

    def write(self, filename: str) -> None:
        """Writes the XML to a file."""
        self._tree.write(
            filename,
            doctype='<!DOCTYPE facilities SYSTEM "http://www.matsim.org/files/dtd/facilities_v1.dtd">',
            encoding="utf-8",
            pretty_print=True,
            xml_declaration=True,
        )


class NetworkBuilder:
    """Builder class for `network.xml`."""

    def __init__(self):
        self._root_elem = etree.Element("network")
        self._root_elem.append(etree.Comment("Generated by " + __file__))
        self._nodes_elem = etree.SubElement(self._root_elem, "nodes")
        self._links_elem = etree.SubElement(
            self._root_elem,
            "links",
            {
                "capperiod": "01:00:00",
                "effectivecellsize": "7.5",
                "effectivelanewidth": "3.75",
            },
        )

        self._tree = etree.ElementTree(element=self._root_elem)

        self._next_node_id = 1
        self._next_link_id = 1
        self._node_ids: Set[int] = set()

    def add_node(self, x: float, y: float) -> int:
        """Adds a node at (x, y).

        Args:
            x: X-offset of the node
            y: Y-offset of the node

        Returns:
            ID of the created node
        """
        node_id = self._next_node_id
        assert node_id not in self._node_ids, f"Node ID already used: {node_id}"
        etree.SubElement(
            self._nodes_elem,
            "node",
            {
                "id": str(node_id),
                "x": str(float(x)),
                "y": str(float(y)),
            },
        )
        self._node_ids.add(node_id)
        self._next_node_id += 1
        return node_id

    def add_link(
        self,
        from_node: int,
        to_node: int,
        *,
        length: float,
        freespeed: float,
        capacity: float,
    ) -> int:
        """Adds a link going from one node to another.

        Args:
            from_node: ID of the beginning node
            to_node: ID of the end node
            length: Distance between the two nodes
            freespeed: Max allowed speed in the link (m/s)
            capacity: Link capacity (vehicles / hour)

        Returns:
            ID of the created link
        """
        link_id = self._next_link_id
        etree.SubElement(
            self._links_elem,
            "link",
            {
                "id": str(self._next_link_id),
                "from": str(from_node),
                "to": str(to_node),
                "length": str(float(length)),
                # Use 50 km/h for speed limit
                "freespeed": str(freespeed),
                # Set capacity to a large value to disregard traffic congestion
                # effects for now
                "capacity": str(float(capacity)),
                "permlanes": "1",
            },
        )
        self._next_link_id += 1
        return link_id

    def add_2way_links(
        self,
        node_a: int,
        node_b: int,
        *,
        length: float,
        freespeed: float,
        capacity: float,
    ) -> Tuple[int, int]:
        """Adds two links connecting two nodes, going in opposite directions.

        Args:
            node_a: ID of node A
            node_b: ID of node B
            length: Distance between the two nodes
            freespeed: Max allowed speed in the link (m/s)
            capacity: Link capacity (vehicles / hour)

        Returns:
            Tuple containing the IDs of the created links.
            The first link is A -> B, and the second B -> A.
        """
        return (
            self.add_link(
                node_a, node_b, length=length, freespeed=freespeed, capacity=capacity
            ),
            self.add_link(
                node_b, node_a, length=length, freespeed=freespeed, capacity=capacity
            ),
        )

    def write(self, filename: str) -> None:
        """Writes the XML to a file."""
        self._tree.write(
            filename,
            doctype='<!DOCTYPE network SYSTEM "http://www.matsim.org/files/dtd/network_v1.dtd">',
            encoding="utf-8",
            pretty_print=True,
            xml_declaration=True,
        )


class PlansBuilder:
    """Builder class for `plans.xml`"""

    def __init__(self):
        self._root_elem = etree.Element("plans")
        self._root_elem.append(etree.Comment("Generated by " + __file__))

        self._tree = etree.ElementTree(element=self._root_elem)

        self._next_person_id = 1

    def add_person(
        self,
        *,
        home: Facility,
        workplace: Facility,
        shop: Facility,
        home_end_time: Union[datetime.time, datetime.datetime],
        work_end_time: Union[datetime.time, datetime.datetime],
        shopping_end_time: Union[datetime.time, datetime.datetime],
    ) -> int:
        """Add a person with a randomly generated plan.

        The generated plan is: home -> workplace -> shop -> home.

        This makes no attempt to generate a path (i.e. series of link IDs to
        traverse) for each <leg>.
        Instead, the generate configuration relies on MATSim to automatically
        discover paths.
        """
        person_id = self._next_person_id
        person_elem = etree.SubElement(
            self._root_elem, "person", {"id": str(person_id)}
        )
        self._next_person_id += 1

        plan_elem = etree.SubElement(person_elem, "plan")
        etree.SubElement(
            plan_elem,
            "act",
            {
                "type": "home",
                "facility": str(home.id),
                "x": str(float(home.x)),
                "y": str(float(home.y)),
                "end_time": home_end_time.strftime("%H:%M:%S"),
            },
        )
        etree.SubElement(plan_elem, "leg", {"mode": "car"})
        etree.SubElement(
            plan_elem,
            "act",
            {
                "type": "work",
                "facility": str(workplace.id),
                "x": str(float(workplace.x)),
                "y": str(float(workplace.y)),
                "end_time": work_end_time.strftime("%H:%M:%S"),
            },
        )
        etree.SubElement(plan_elem, "leg", {"mode": "car"})
        etree.SubElement(
            plan_elem,
            "act",
            {
                "type": "shopping",
                "facility": str(shop.id),
                "x": str(float(shop.x)),
                "y": str(float(shop.y)),
                "end_time": shopping_end_time.strftime("%H:%M:%S"),
            },
        )
        etree.SubElement(plan_elem, "leg", {"mode": "car"})
        etree.SubElement(
            plan_elem,
            "act",
            {
                "type": "home",
                "facility": str(home.id),
                "x": str(float(home.x)),
                "y": str(float(home.y)),
                # The last activity in a plan does not need an end_time
                # (see Section 2.2.1.2 of MATSim User Guide)
            },
        )

        return person_id

    def write(self, filename: str) -> None:
        """Writes the XML to a file."""
        self._tree.write(
            filename,
            doctype='<!DOCTYPE plans SYSTEM "http://www.matsim.org/files/dtd/plans_v4.dtd">',
            encoding="utf-8",
            pretty_print=True,
            xml_declaration=True,
        )
